diff --git a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
index 624a1fd7e..3dcfe92b5 100644
--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
@@ -803,31 +802,6 @@ public abstract class AnnotationIntrospector
         //    direct sub-class not yet retrofitted may only override
         //    those methods. With 2.8 or later we may consider removal
         //    of these methods
-
-        
-        // Ok: start by refining the main type itself; common to all types
-        Class<?> serClass = findSerializationType(a);
-        if (serClass != null) {
-            if (type.hasRawClass(serClass)) {
-                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
-                //    static typing this way
-                type = type.withStaticTyping();
-            } else {
-                try {
-                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
-                    //   may be needed here too in future?
-                        type = tf.constructGeneralizedType(type, serClass);
-                } catch (IllegalArgumentException iae) {
-                    throw new JsonMappingException(null,
-                            String.format("Failed to widen type %s with annotation (value %s), from '%s': %s",
-                                    type, serClass.getName(), a.getName(), iae.getMessage()),
-                                    iae);
-                }
-            }
-        }
-        // Then further processing for container types
-
-        // First, key type (for Maps, Map-like types):
         if (type.isMapLikeType()) {
             JavaType keyType = type.getKeyType();
             Class<?> keyClass = findSerializationKeyType(a, keyType);
@@ -892,9 +865,36 @@ public abstract class AnnotationIntrospector
                type = type.withContentType(contentType);
            }
         }
+        // Ok: start by refining the main type itself; common to all types
+        Class<?> serClass = findSerializationType(a);
+        if (serClass != null) {
+            if (type.hasRawClass(serClass)) {
+                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
+                //    static typing this way
+                type = type.withStaticTyping();
+            } else {
+                try {
+                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
+                    //   may be needed here too in future?
+                    if (type.getRawClass().isAssignableFrom(serClass)) { // common case
+                        type = tf.constructGeneralizedType(type, serClass);
+                    } else if (serClass.isAssignableFrom(type.getRawClass())) { // specialization, ok as well
+                        type = tf.constructSpecializedType(type, serClass);
+                    } else {
+                        throw new JsonMappingException(null,
+                                String.format("Can not refine serialization type %s into %s; types not related",
+                                        type, serClass.getName()));
+                    }
+                } catch (IllegalArgumentException iae) {
+                    throw new JsonMappingException(null,
+                            String.format("Failed to widen type %s with annotation (value %s), from '%s': %s",
+                                    type, serClass.getName(), a.getName(), iae.getMessage()),
+                                    iae);
+                }
+            }
+        }
         return type;
     }
-
     /*
     /**********************************************************
     /* Serialization: class annotations
