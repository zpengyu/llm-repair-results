diff --git a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
index 2d1a815..cd6ddee 100644
--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
@@ -99,50 +86,71 @@ public class NullPropertyPointer extends PropertyPointer {
                     + ", path does not match a changeable location");
         }
     }
-
     public NodePointer createPath(JXPathContext context) {
-        NodePointer newParent = parent.createPath(context);
-        if (isAttribute()) {
-            return newParent.createAttribute(context, getName());
+        if (parent instanceof NullPointer){
+            NodePointer propertyPointer = parent.createPath(context);
+            if (isAttribute()) {
+                return propertyPointer.createAttribute(context, getName());
+            }
+            else {
+                return propertyPointer.createChild(context, getName(), index);
+            }
         }
         else {
-            // Consider these two use cases:
-            // 1. The parent pointer of NullPropertyPointer is
-            //    a PropertyOwnerPointer other than NullPointer. When we call
-            //    createPath on it, it most likely returns itself. We then
-            //    take a PropertyPointer from it and get the PropertyPointer
-            //    to expand the collection for the corresponding property.
-            //
-            // 2. The parent pointer of NullPropertyPointer is a NullPointer.
-            //    When we call createPath, it may return a PropertyOwnerPointer
-            //    or it may return anything else, like a DOMNodePointer.
-            //    In the former case we need to do exactly what we did in use 
-            //    case 1.  In the latter case, we simply request that the 
-            //    non-property pointer expand the collection by itself.
-            if (newParent instanceof PropertyOwnerPointer) {
-                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
-                newParent = pop.getPropertyPointer();
+            NodePointer newParent = parent.createPath(context);
+            if (isAttribute()) {
+                return newParent.createAttribute(context, getName());
+            }
+            else {
+                // Consider these two use cases:
+                // 1. The parent pointer of NullPropertyPointer is
+                //    a PropertyOwnerPointer other than NullPointer. When we call
+                //    createPath on it, it most likely returns itself. We then
+                //    take a PropertyPointer from it and get the PropertyPointer
+                //    to expand the collection for the corresponding property.
+                //
+                // 2. The parent pointer of NullPropertyPointer is a NullPointer.
+                //    When we call createPath, it may return a PropertyOwnerPointer
+                //    or it may return anything else, like a DOMNodePointer.
+                //    In the former case we need to do exactly what we did in use
+                //    case 1.  In the latter case, we simply request that the
+                //    non-property pointer expand the collection by itself.
+                if (newParent instanceof PropertyOwnerPointer) {
+                    PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
+                    newParent = pop.getPropertyPointer();
+                }
+                return newParent.createChild(context, getName(), getIndex());
             }
-            return newParent.createChild(context, getName(), getIndex());
         }
     }
-
     public NodePointer createPath(JXPathContext context, Object value) {
-        NodePointer newParent = parent.createPath(context);
-        if (isAttribute()) {
-            NodePointer pointer = newParent.createAttribute(context, getName());
-            pointer.setValue(value);
-            return pointer;
+        if (parent instanceof NullPointer){
+            NodePointer propertyPointer = parent.createPath(context);
+            if (isAttribute()) {
+                NodePointer pointer = propertyPointer.createAttribute(context, getName());
+                pointer.setValue(value);
+                return pointer;
+            }
+            else {
+                return propertyPointer.createChild(context, getName(), index, value);
+            }
         }
         else {
-            if (newParent instanceof PropertyOwnerPointer) {
-                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
-                newParent = pop.getPropertyPointer();
+            NodePointer newParent = parent.createPath(context);
+            if (isAttribute()) {
+                NodePointer pointer = newParent.createAttribute(context, getName());
+                pointer.setValue(value);
+                return pointer;
+            }
+            else {
+                if (newParent instanceof PropertyOwnerPointer) {
+                    PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
+                    newParent = pop.getPropertyPointer();
+                }
+                return newParent.createChild(context, getName(), index, value);
             }
-            return newParent.createChild(context, getName(), index, value);
         }
     }
-    
     public NodePointer createChild(
             JXPathContext context,
             QName name,
