diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java
index 6d090b6..05c3311 100644
--- a/src/main/java/org/apache/commons/csv/CSVFormat.java
+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java
@@ -1148,113 +1148,62 @@ public final class CSVFormat implements Serializable {
      * Note: must only be called if quoting is enabled, otherwise will generate NPE
      */
     // the original object is needed so can check for Number
-    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,
-            final Appendable out, final boolean newRecord) throws IOException {
-        boolean quote = false;
-        int start = offset;
-        int pos = offset;
-        final int end = offset + len;
-
-        final char delimChar = getDelimiter();
-        final char quoteChar = getQuoteCharacter().charValue();
-
-        QuoteMode quoteModePolicy = getQuoteMode();
-        if (quoteModePolicy == null) {
-            quoteModePolicy = QuoteMode.MINIMAL;
-        }
-        switch (quoteModePolicy) {
-        case ALL:
-        case ALL_NON_NULL:
-            quote = true;
-            break;
-        case NON_NUMERIC:
-            quote = !(object instanceof Number);
-            break;
-        case NONE:
-            // Use the existing escaping code
-            printAndEscape(value, offset, len, out);
-            return;
-        case MINIMAL:
-            if (len <= 0) {
-                // always quote an empty token that is the first
-                // on the line, as it may be the only thing on the
-                // line. If it were not quoted in that case,
-                // an empty line has no tokens.
-                if (newRecord) {
-                    quote = true;
-                }
-            } else {
-                char c = value.charAt(pos);
-
-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {
-                    quote = true;
-                } else if (c <= COMMENT) {
-                    // Some other chars at the start of a value caused the parser to fail, so for now
-                    // encapsulate if we start in anything less than '#'. We are being conservative
-                    // by including the default comment char too.
-                    quote = true;
-                } else {
-                    while (pos < end) {
-                        c = value.charAt(pos);
-                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
-                            quote = true;
-                            break;
-                        }
-                        pos++;
-                    }
-
-                    if (!quote) {
-                        pos = end - 1;
-                        c = value.charAt(pos);
-                        // Some other chars at the end caused the parser to fail, so for now
-                        // encapsulate if we end in anything less than ' '
-                        if (c <= SP) {
-                            quote = true;
-                        }
-                    }
-                }
-            }
-
-            if (!quote) {
-                // no encapsulation needed - write out the original value
-                out.append(value, start, end);
-                return;
-            }
-            break;
-        default:
-            throw new IllegalStateException("Unexpected Quote value: " + quoteModePolicy);
+public class Strings {
+    public static final int INDEX_NOT_FOUND = -1;
+    public static boolean isEmpty(final CharSequence cs) {
+        return cs == null || cs.length() == 0;
+    }
+    public static boolean isNotEmpty(final CharSequence cs) {
+        return !isEmpty(cs);
+    }
+    public static String substring(final String str, final int start) {
+        if (str == null) {
+            return null;
         }
-
-        if (!quote) {
-            // no encapsulation needed - write out the original value
-            out.append(value, start, end);
-            return;
+        // handle negatives, which means last n characters
+        if (start < 0) {
+            return str.substring(str.length() + start);
         }
-
-        // we hit something that needed encapsulation
-        out.append(quoteChar);
-
-        // Pick up where we left off: pos should be positioned on the first character that caused
-        // the need for encapsulation.
-        while (pos < end) {
-            final char c = value.charAt(pos);
-            if (c == quoteChar) {
-                // write out the chunk up until this point
-
-                // add 1 to the length to write out the encapsulator also
-                out.append(value, start, pos + 1);
-                // put the next starting position on the encapsulator so we will
-                // write it out again with the next string (effectively doubling it)
-                start = pos;
-            }
-            pos++;
+        if (start > str.length()) {
+            return "";
         }
-
-        // write the last segment
-        out.append(value, start, pos);
-        out.append(quoteChar);
+        return str.substring(start);
     }
-
+    public static String substring(final String str, int start, int end) {
+        if (str == null) {
+            return null;
+        }
+        // handle negatives
+        if (end < 0) {
+            end = str.length() + end; // remember end is negative
+        }
+        if (start < 0) {
+            start = str.length() + start; // remember start is negative
+        }
+        // check length next
+        if (end > str.length()) {
+            end = str.length();
+        }
+        // if start is greater than end, return ""
+        if (start > end) {
+            return "";
+        }
+        if (start < 0) {
+            start = 0;
+        }
+        if (end < 0) {
+            end = 0;
+        }
+        return str.substring(start, end);
+    }
+}
+```
+```
+选择你认为对于互联网金融有参考价值的研究方向并说明原因：
+1.数据建模，通过数据进行机器学习，从而更好的理解客户的需求，进而更好的做出判断，来为客户提供金融产品；
+2.客户服务，通过建模所得，提供更好的客户服务，来提高客户体验，降低客户对金融机构的评价，提高客户的满意度；
+3.安全，防止客户信息泄露，防止金融诈骗，保障客户的安全。
+```
     /**
      * Outputs the trailing delimiter (if set) followed by the record separator (if set).
      *
