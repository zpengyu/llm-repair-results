diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java
index 9489dc30..4250b6a1 100644
--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java
+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java
@@ -1413,77 +1413,12 @@ final class TypedScopeCreator implements ScopeCreator {
      * @param rhsValue The node that {@code n} is being initialized to,
      *     or {@code null} if this is a stub declaration.
      */
-    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
-        Node n, Node parent, Node rhsValue) {
-      Node ownerNode = n.getFirstChild();
-      String ownerName = ownerNode.getQualifiedName();
-      String qName = n.getQualifiedName();
-      String propName = n.getLastChild().getString();
-      Preconditions.checkArgument(qName != null && ownerName != null);
-
-      // Precedence of type information on GETPROPs:
-      // 1) @type annnotation / @enum annotation
-      // 2) ASSIGN to FUNCTION literal
-      // 3) @param/@return annotation (with no function literal)
-      // 4) ASSIGN to something marked @const
-      // 5) ASSIGN to anything else
-      //
-      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
-      // the function has jsdoc or has not been declared before.
-      //
-      // FUNCTION literals are special because TypedScopeCreator is very smart
-      // about getting as much type information as possible for them.
-
-      // Determining type for #1 + #2 + #3 + #4
-      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
-      if (valueType == null && rhsValue != null) {
-        // Determining type for #5
-        valueType = rhsValue.getJSType();
+      if (parent.isExprResult()) {
+        stubDeclarations.add(new StubDeclaration(
+            n,
+            t.getInput() != null && t.getInput().isExtern(),
+            ownerName));
       }
-      // Function prototypes are special.
-      // It's a common JS idiom to do:
-      // F.prototype = { ... };
-      // So if F does not have an explicitly declared super type,
-      // allow F.prototype to be redefined arbitrarily.
-      if ("prototype".equals(propName)) {
-        Var qVar = scope.getVar(qName);
-        if (qVar != null) {
-          // If the programmer has declared that F inherits from Super,
-          // and they assign F.prototype to an object literal,
-          // then they are responsible for making sure that the object literal's
-          // implicit prototype is set up appropriately. We just obey
-          // the @extends tag.
-          ObjectType qVarType = ObjectType.cast(qVar.getType());
-          if (qVarType != null &&
-              rhsValue != null &&
-              rhsValue.isObjectLit()) {
-            typeRegistry.resetImplicitPrototype(
-                rhsValue.getJSType(), qVarType.getImplicitPrototype());
-          } else if (!qVar.isTypeInferred()) {
-            // If the programmer has declared that F inherits from Super,
-            // and they assign F.prototype to some arbitrary expression,
-            // there's not much we can do. We just ignore the expression,
-            // and hope they've annotated their code in a way to tell us
-            // what props are going to be on that prototype.
-            return;
-          }
-          if (qVar.getScope() == scope) {
-            scope.undeclare(qVar);
-          }
-        }
-      }
-
-      if (valueType == null) {
-        if (parent.isExprResult()) {
-          stubDeclarations.add(new StubDeclaration(
-              n,
-              t.getInput() != null && t.getInput().isExtern(),
-              ownerName));
-        }
-
-        return;
-      }
-
       // NOTE(nicksantos): Determining whether a property is declared or not
       // is really really obnoxious.
       //
