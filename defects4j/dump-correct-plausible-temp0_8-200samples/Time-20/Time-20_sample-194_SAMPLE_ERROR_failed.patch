diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 1ff78bfe..30a85261 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -2765,15 +2765,13 @@ public class DateTimeFormatterBuilder {
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             DateTimeParser[] parsers = iParsers;
             int length = parsers.length;
-
             final Object originalState = bucket.saveState();
             boolean isOptional = false;
-
             int bestValidPos = position;
             Object bestValidState = null;
-
             int bestInvalidPos = position;
-
+            int lastValue = -1;
+            int lastValidValue = -1;
             for (int i=0; i<length; i++) {
                 DateTimeParser parser = parsers[i];
                 if (parser == null) {
@@ -2797,6 +2794,8 @@ public class DateTimeFormatterBuilder {
                         bestValidPos = parsePos;
                         bestValidState = bucket.saveState();
                     }
+                    lastValue = i;
+                    lastValidValue = i;
                 } else {
                     if (parsePos < 0) {
                         parsePos = ~parsePos;
@@ -2813,11 +2811,22 @@ public class DateTimeFormatterBuilder {
                 if (bestValidState != null) {
                     bucket.restoreState(bestValidState);
                 }
-                return bestValidPos;
+                if (lastValue == -1) {
+                    // Find the value that must be used for the field.
+                    for (int i=length; --i>=0; ) {
+                        DateTimeParser parser = parsers[i];
+                        if (parser != null) {
+                            bucket.saveField(this, i);
+                            return bestValidPos;
+                        }
+                    }
+                    throw new IllegalStateException();
+                } else {
+                    bucket.saveField(this, lastValue);
+                    return bestValidPos;
+                }
             }
-
             return ~bestInvalidPos;
-        }
-    }
+        }    }
 
 }
