###Provide a fix for the buggy function
###Buggy Function
class FibonacciExample {
    public static void main(String args[]) {
        int n1 = 0, n2 = 1, n3, i, count = 10;

        System.out.print(n1 + " " + n2);

        for (i = 2; i < count; ++i) {
            n3 = n1 - n2;
            System.out.print(" " + n3);
            n1 = n2;
            n2 = n3;
        }
    }
}

###Fixed Function
class FibonacciExample {
    public static void main(String args[]) {
        int n1 = 0, n2 = 1, n3, i, count = 10;

        System.out.print(n1 + " " + n2);

        for (i = 2; i < count; ++i) {
            n3 = n1 + n2;
            System.out.print(" " + n3);
            n1 = n2;
            n2 = n3;
        }
    }
}

###Provide a fix for the buggy function
###Buggy Function
protected BasePeriod(long duration) {
    this(duration, null, null);
    // bug [3264409]
}
###Fixed Function
protected BasePeriod(long duration) {
    super();
    // bug [3264409]
    iType = PeriodType.time();
    int[] values = ISOChronology.getInstanceUTC().get(this, duration);
    iType = PeriodType.standard();
    iValues = new int[8];
    System.arraycopy(values, 0, iValues, 4, 4);
}
###Provide a fix for the buggy function
###Buggy Function
        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
            DateTimeParser[] parsers = iParsers;
            int length = parsers.length;

            final Object originalState = bucket.saveState();
            boolean isOptional = false;

            int bestValidPos = position;
            Object bestValidState = null;

            int bestInvalidPos = position;

            for (int i=0; i<length; i++) {
                DateTimeParser parser = parsers[i];
                if (parser == null) {
                    // The empty parser wins only if nothing is better.
                    if (bestValidPos <= position) {
                        return position;
                    }
                    isOptional = true;
                    break;
                }
                int parsePos = parser.parseInto(bucket, text, position);
                if (parsePos >= position) {
                    if (parsePos > bestValidPos) {
                        if (parsePos >= text.length() ||
                            (i + 1) >= length || parsers[i + 1] == null) {

                            // Completely parsed text or no more parsers to
                            // check. Skip the rest.
                            return parsePos;
                        }
                        bestValidPos = parsePos;
                        bestValidState = bucket.saveState();
                    }
                } else {
                    if (parsePos < 0) {
                        parsePos = ~parsePos;
                        if (parsePos > bestInvalidPos) {
                            bestInvalidPos = parsePos;
                        }
                    }
                }
                bucket.restoreState(originalState);
            }

            if (bestValidPos > position || (bestValidPos == position && isOptional)) {
                // Restore the state to the best valid parse.
                if (bestValidState != null) {
                    bucket.restoreState(bestValidState);
                }
                return bestValidPos;
            }

            return ~bestInvalidPos;
        }

###Fixed Function
