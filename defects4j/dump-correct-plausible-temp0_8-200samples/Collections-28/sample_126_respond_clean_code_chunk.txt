    private class PrefixRangeMap extends RangeMap {
        private final K prefix;
        private final int offsetInBits;
        private final int lengthInBits;
        private K fromKey = null;
        private K toKey = null;
        private transient int expectedModCount = 0;
        private int size = -1;
        /**
         * Creates a {@link PrefixRangeMap}.
         */
        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {
            this.prefix = prefix;
            this.offsetInBits = offsetInBits;
            this.lengthInBits = lengthInBits;
        }
        /**
         * This method does two things. It determines the FROM
         * and TO range of the {@link PrefixRangeMap} and the number
         * of elements in the range. This method must be called every
         * time the {@link Trie} has changed.
         */
        private int fixup() {
            // The trie has changed since we last found our toKey / fromKey
            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {
                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();
                size = 0;
                Map.Entry<K, V> entry = null;
                if (it.hasNext()) {
                    entry = it.next();
                    size = 1;
                }
                fromKey = entry == null ? null : entry.getKey();
                if (fromKey != null) {
                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);
                    fromKey = prior == null ? null : prior.getKey();
                }
                toKey = fromKey;
                while (it.hasNext()) {
                    ++size;
                    entry = it.next();
                }
                toKey = entry == null ? null : entry.getKey();
                if (toKey != null) {
                    entry = nextEntry((TrieEntry<K, V>)entry);
                    toKey = entry == null ? null : entry.getKey();
                }
                expectedModCount = AbstractPatriciaTrie.this.modCount;
            }
            return size;
        }
        @Override
        public K firstKey() {
            fixup();
            Map.Entry<K,V> e = null;
            if (fromKey == null) {
                e = firstEntry();
            } else {
                e = higherEntry(fromKey);
            }
            final K first = e != null ? e.getKey() : null;
            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {
                throw new NoSuchElementException();
            }
            return first;
        }
        @Override
        public K lastKey() {
            fixup();
            Map.Entry<K,V> e = null;
            if (toKey == null) {
                e = lastEntry();
            } else {
                e = lowerEntry(toKey);
            }
            final K last = e != null ? e.getKey() : null;
            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {
                throw new NoSuchElementException();
            }
            return last;
        }
        /**
         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.
         */
        @Override
        protected boolean inRange(final K key) {
            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);
        }
        /**
         * Same as {@link #inRange(Object)}.
         */
        @Override
        protected boolean inRange2(final K key) {
            return inRange(key);
        }
        /**
         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.
         */
        @Override
        protected boolean inFromRange(final K key, final boolean forceInclusive) {
            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);
        }
        /**
         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.
         */
        @Override
        protected boolean inToRange(final K key, final boolean forceInclusive) {
            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);
        }
        @Override
        protected Set<Map.Entry<K, V>> createEntrySet() {
            return new PrefixRangeEntrySet(this);
        }
        @Override
        public K getFromKey() {
            return fromKey;
        }
        @Override
        public K getToKey() {
            return toKey;
        }
        @Override
        public boolean isFromInclusive() {
            return false;
        }
        @Override
        public boolean isToInclusive() {
            return false;
        }
        @Override
        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,
                                                 final K toKey, final boolean toInclusive) {
            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
        }
    }
* [Fixed-Size Map Based on Trie Data Structure in Java](https://github.com/sandipchitale/FixedSizeTreeMap)
* [Patricia Trie](https://bitbucket.org/ssauat/patricia-trie/wiki/Home)
* [Patricia Trie](https://code.google.com/archive/p/patricia-trie/)
* [RadixTree](https://code.google.com/archive/p/radixtree/)
* [Patricia Trie](https://sourceforge.net/projects/pattrie/)
If you like this project, please consider [donating](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=sandip%2eorg1%40gmail%2ecom&lc=US&item_name=Sandip%20Chitale%20Donation&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donate_SM%2egif%3aNonHosted):
[![Donate to this project using Paypal](https://img.shields.io/badge/paypal-donate-yellow.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=sandip%2eorg1%40gmail%2ecom&lc=US&item_name=Sandip%20Chitale%20Donation&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donate_SM%2egif%3aNonHosted)
[![Contact me on Codementor](https://cdn.codementor.io/badges/contact_me_github.svg)](https://www.codementor.io/sandip?utm_source=github&utm_medium=button&utm_term=sandip&utm_campaign=github)
This code is licensed under [Apache License v2.0](http://www.apache.org/licenses/LICENSE-2.0)