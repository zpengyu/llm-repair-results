diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
index 3c89dc109..9896f41c3 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
@@ -823,7 +820,59 @@ public class BeanDeserializer
                 continue;
             }
         }
-
+        // 22-Aug-2018, tatu: One special case, where we may have a property
+        //   added by "creator" (constructor, factory method) but not part
+        //   of JSON; this is tricky but possible.
+        if (t.isStructStart()) {
+            // 14-Oct-2018, tatu: as per [databind#2265], may actually skip over initial
+            //    `FIELD_NAME` and so need to check
+            if (t == JsonToken.START_OBJECT) {
+                t = p.nextToken();
+            }
+            // either way, should get FIELD_NAME here; if not, it's an error
+            if (t == JsonToken.FIELD_NAME) {
+                do {
+                    String propName = p.getCurrentName();
+                    p.nextToken();
+                    // Object Id property?
+                    if (buffer.readIdProperty(propName)) {
+                        continue;
+                    }
+                    // regular property? needs buffering
+                    SettableBeanProperty prop = _beanProperties.find(propName);
+                    if (prop != null) {
+                        buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
+                        continue;
+                    }
+                    // Things marked as ignorable should not be passed to any setter
+                    if (_ignorableProps != null && _ignorableProps.contains(propName)) {
+                        handleIgnoredProperty(p, ctxt, handledType(), propName);
+                        continue;
+                    }
+                    // 29-Nov-2016, tatu: probably should try to avoid sending content
+                    //    both to any setter AND buffer... but, for now, the only thing
+                    //    we can do.
+                    // how about any setter? We'll get copies but...
+                    if (_anySetter == null) {
+                        // but... others should be passed to unwrapped property deserializers
+                        tokens.writeFieldName(propName);
+                        tokens.copyCurrentStructure(p);
+                    } else {
+                        // Need to copy to a separate buffer first
+                        TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);
+                        tokens.writeFieldName(propName);
+                        tokens.append(b2);
+                        try {
+                            buffer.bufferAnyProperty(_anySetter, propName,
+                                    _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));
+                        } catch (Exception e) {
+                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
+                        }
+                        continue;
+                    }
+                } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);
+            }
+        }
         // We hit END_OBJECT, so:
         Object bean;
         try {
