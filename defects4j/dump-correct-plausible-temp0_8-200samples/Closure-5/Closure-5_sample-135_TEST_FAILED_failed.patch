diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java
index 2f5a8e10..59c15bd5 100644
--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java
+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java
@@ -166,14 +165,11 @@ class InlineObjectLiterals implements CompilerPass {
         if (parent.isGetProp()) {
           Preconditions.checkState(parent.getFirstChild() == name);
           // A call target may be using the object as a 'this' value.
-          if (gramps.isCall()
-              && gramps.getFirstChild() == parent) {
+          if (gramps.isCall() && gramps.getFirstChild() == parent) {
             return false;
           }
-
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
-
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
           // object, then the value is undefined. This is not true, because
@@ -186,6 +182,10 @@ class InlineObjectLiterals implements CompilerPass {
           if (!validProperties.contains(propName)) {
             if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
               validProperties.add(propName);
+            } else if (parent.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
+              // We can't know whether this is really a property
+              // reference, because that would require static analysis.
+              return false;
             } else {
               return false;
             }
