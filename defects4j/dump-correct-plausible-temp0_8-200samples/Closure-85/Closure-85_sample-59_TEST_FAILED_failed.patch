diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
index 60bfd244..04fc4c71 100644
--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
@@ -45,18 +45,14 @@ import java.util.logging.Logger;
  *
  */
 class UnreachableCodeElimination extends AbstractPostOrderCallback
-    implements CompilerPass, ScopedCallback  {
+    implements CompilerPass, ScopedCallback {
   private static final Logger logger =
     Logger.getLogger(UnreachableCodeElimination.class.getName());
-
   private final AbstractCompiler compiler;
   private final boolean removeNoOpStatements;
-
   Deque<ControlFlowGraph<Node>> cfgStack =
       new LinkedList<ControlFlowGraph<Node>>();
-
   ControlFlowGraph<Node> curCfg = null;
-
   UnreachableCodeElimination(AbstractCompiler compiler,
       boolean removeNoOpStatements) {
     this.compiler = compiler;
@@ -203,14 +182,7 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
       // Not always trivial to remove, let FoldContants work its magic later.
       return;
     }
-
     switch (n.getType()) {
-      // Removing an unreachable DO node is messy because it means we still have
-      // to execute one iteration. If the DO's body has breaks in the middle, it
-      // can get even more trickier and code size might actually increase.
-      case Token.DO:
-        return;
-
       case Token.BLOCK:
         // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs
         if (parent.getType() == Token.TRY) {
