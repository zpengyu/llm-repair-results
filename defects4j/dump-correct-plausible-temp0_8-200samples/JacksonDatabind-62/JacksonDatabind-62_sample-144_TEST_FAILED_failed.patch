diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
index af4270610..99c63278d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
@@ -190,12 +190,19 @@ public class CollectionDeserializer
                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
         // also, often value deserializer is resolved here:
         JsonDeserializer<?> valueDeser = _valueDeserializer;
-        
         // May have a content converter
         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);
-        final JavaType vt = _collectionType.getContentType();
+        JavaType vt = _collectionType.getContentType();
         if (valueDeser == null) {
-            valueDeser = ctxt.findContextualValueDeserializer(vt, property);
+            // 30-Sep-2015, tatu: One special thing -- as per [databind#625] we can not yet
+            //   fully resolve generic types when handling "unwrapped" case. So we have
+            //   to delay resolution a bit.
+            if ((_unwrapSingle == Boolean.TRUE) && !vt.isPrimitive()) {
+                valueDeser = ctxt.findContextualValueDeserializer(vt, property);
+                vt = ctxt.constructType(vt.getRawClass());
+            } else {
+                valueDeser = ctxt.findContextualValueDeserializer(vt, property);
+            }
         } else { // if directly assigned, probably not yet contextual, so:
             valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);
         }
