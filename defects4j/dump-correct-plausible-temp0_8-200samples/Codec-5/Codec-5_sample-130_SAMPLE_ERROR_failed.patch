diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java
index b5895635..0e8fdbba 100644
--- a/src/java/org/apache/commons/codec/binary/Base64.java
+++ b/src/java/org/apache/commons/codec/binary/Base64.java
@@ -583,17 +582,35 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {
         // EOF (-1) and first time '=' character is encountered in stream.
         // This approach makes the '=' padding characters completely optional.
         if (eof && modulus != 0) {
-
-            x = x << 6;
-            switch (modulus) {
-                case 2 :
+            // We reached EOF.  There are two options: actual EOF (-1) or
+            // one of the '=' characters.
+            //
+            // Test if we have consumed all the buffer.  If not, there are
+            // two cases:
+            //
+            // 1) The buffer is read one byte at a time by the Base64 stream.
+            //    In this case the '=' character will be encountered in the
+            //    next read and an exception thrown.
+            //
+            // 2) The buffer is filled by the Base64 stream.  In this case,
+            //    the '=' padding is already correctly set.
+            //
+            // In both cases, the remaining bytes in the buffer must be
+            // consumed.
+            if (buffer != null && buffer.length - pos > 0) {
+                if (!isInAlphabet(buffer[pos])) {
                     x = x << 6;
-                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
-                    break;
-                case 3 :
-                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
-                    break;
+                    switch (modulus) {
+                        case 2 :
+                            x = x << 6;
+                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
+                            break;
+                        case 3 :
+                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
+                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
+                            break;
+                    }
+                }
             }
         }
     }
