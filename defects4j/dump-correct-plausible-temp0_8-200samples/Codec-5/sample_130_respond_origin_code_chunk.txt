    void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            // We reached EOF.  There are two options: actual EOF (-1) or
            // one of the '=' characters.
            //
            // Test if we have consumed all the buffer.  If not, there are
            // two cases:
            //
            // 1) The buffer is read one byte at a time by the Base64 stream.
            //    In this case the '=' character will be encountered in the
            //    next read and an exception thrown.
            //
            // 2) The buffer is filled by the Base64 stream.  In this case,
            //    the '=' padding is already correctly set.
            //
            // In both cases, the remaining bytes in the buffer must be
            // consumed.
            if (buffer != null && buffer.length - pos > 0) {
                if (!isInAlphabet(buffer[pos])) {
                    x = x << 6;
                    switch (modulus) {
                        case 2 :
                            x = x << 6;
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            break;
                        case 3 :
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            break;
                    }
                }
            }
        }
    }

