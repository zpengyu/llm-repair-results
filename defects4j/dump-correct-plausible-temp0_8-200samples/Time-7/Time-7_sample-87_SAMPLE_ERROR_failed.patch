diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java
index 8f9d3948..4ce77aed 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java
@@ -713,20 +711,16 @@ public class DateTimeFormatter {
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
-        if (iOffsetParsed && bucket.getOffsetInteger() != null) {
-            int parsedOffset = bucket.getOffsetInteger();
-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
-            chrono = chrono.withZone(parsedZone);
-        } else if (bucket.getZone() != null) {
-            chrono = chrono.withZone(bucket.getZone());
-        }
+        chrono = bucket.getChronology();
         instant.setChronology(chrono);
         if (iZone != null) {
             instant.setZone(iZone);
         }
         return newPos;
     }
-
+As in symbolic execution, concolic execution also computes symbolic formula. However, the concolic execution algorithms, contrary to the symbolic execution algorithms, are designed to keep symbolic formulae as simple as possible. For example, the concolic execution algorithm performs the branching of code at the granularity of basic blocks instead of individual instructions. In this way, the concolic execution algorithm ensures that for each newly created path, the symbolic formula is as simple as possible. 
+A concrete value is a value that is known at compile-time (and at runtime); 
+in contrast, a symbolic value is a value that is unknown at compile-time (and at runtime) but can be deduced at runtime. 
     /**
      * Parses a datetime from the given text, returning the number of
      * milliseconds since the epoch, 1970-01-01T00:00:00Z.
