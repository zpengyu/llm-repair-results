diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
index 3b323395..75e52959 100644
--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
@@ -84,29 +84,6 @@ class UnreachableCodeElimination implements CompilerPass {
       });
   }
 
-  private class EliminationPass extends AbstractShallowCallback {
-    private final ControlFlowGraph<Node> cfg;
-    private EliminationPass(ControlFlowGraph<Node> cfg) {
-      this.cfg = cfg;
-    }
-
-    @Override
-    public void visit(NodeTraversal t, Node n, Node parent) {
-      if (parent == null || n.isFunction() || n.isScript()) {
-        return;
-      }
-      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);
-      if (gNode == null) { // Not in CFG.
-        return;
-      }
-      if (gNode.getAnnotation() != GraphReachability.REACHABLE ||
-          (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {
-        removeDeadExprStatementSafely(n);
-        return;
-      }
-      tryRemoveUnconditionalBranching(n);
-    }
-
     /**
      * Tries to remove n if it is an unconditional branch node (break, continue,
      * or return) and the target of n is the same as the the follow of n.
@@ -125,8 +102,7 @@ class UnreachableCodeElimination implements CompilerPass {
      * @returns The target of this jump. If the target is also useless jump,
      *     the target of that useless jump recursively.
      */
-    @SuppressWarnings("fallthrough")
-    private void tryRemoveUnconditionalBranching(Node n) {
+    private Node tryRemoveUnconditionalBranching(Node n) {
       /*
        * For each unconditional branching control flow node, check to see
        * if the ControlFlowAnalysis.computeFollowNode of that node is same as
@@ -136,18 +112,14 @@ class UnreachableCodeElimination implements CompilerPass {
        * if-else conversion but it handles more complicated switch statements
        * much more nicely.
        */
-
       // If n is null the target is the end of the function, nothing to do.
       if (n == null) {
-         return;
+        return null;
       }
-
       DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);
-
       if (gNode == null) {
-        return;
+        return null;
       }
-
       switch (n.getType()) {
         case Token.RETURN:
           if (n.hasChildren()) {
@@ -168,53 +139,65 @@ class UnreachableCodeElimination implements CompilerPass {
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
             if (nextCfgNode == fallThrough) {
-              removeNode(n);
+              if (logger.isLoggable(Level.FINE)) {
+                logger.fine("Removing " + n.toString());
+              }
+              codeChanged = true;
+              compiler.reportCodeChange();
+              NodeUtil.redeclareVarsInsideBranch(n);
+              NodeUtil.removeChild(n.getParent(), n);
+              // We can try removing this node's parent.
+              return n.getParent();
             }
           }
       }
+      return null;
     }
-
-
-    private Node computeFollowing(Node n) {
-      Node next = ControlFlowAnalysis.computeFollowNode(n);
-      while (next != null && next.isBlock()) {
-        if (next.hasChildren()) {
-          next = next.getFirstChild();
-        } else {
-          next = computeFollowing(next);
-        }
+  private class EliminationPass extends AbstractShallowCallback {
+    private final ControlFlowGraph<Node> cfg;
+    private EliminationPass(ControlFlowGraph<Node> cfg) {
+      this.cfg = cfg;
+    }
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      if (parent == null || n.isFunction() || n.isScript()) {
+        return;
+      }
+      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);
+      if (gNode == null) { // Not in CFG.
+        return;
       }
-      return next;
+      if (gNode.getAnnotation() != GraphReachability.REACHABLE ||
+          (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {
+        removeDeadExprStatementSafely(n);
+        return;
+      }
+      tryRemoveUnconditionalBranching(n);
     }
-
-    private void removeDeadExprStatementSafely(Node n) {
+    private Node removeDeadExprStatementSafely(Node n) {
       Node parent = n.getParent();
       if (n.isEmpty() || (n.isBlock() && !n.hasChildren())) {
         // Not always trivial to remove, let FoldConstants work its magic later.
-        return;
+        return null;
       }
-
       // TODO(user): This is a problem with removeNoOpStatements.
       // Every expression in a FOR-IN header looks side effect free on its own.
       if (NodeUtil.isForIn(parent)) {
-        return;
+        return null;
       }
-
       switch (n.getType()) {
         // Removing an unreachable DO node is messy b/c it means we still have
         // to execute one iteration. If the DO's body has breaks in the middle,
         // it can get even more tricky and code size might actually increase.
         case Token.DO:
-          return;
-
+          return null;
         case Token.BLOCK:
           // BLOCKs are used in several ways including wrapping CATCH
           // blocks in TRYs
           if (parent.isTry() && NodeUtil.isTryCatchNodeContainer(n)) {
-            return;
+            return null;
           }
           break;
-
         case Token.CATCH:
           Node tryNode = parent.getParent();
           NodeUtil.maybeAddFinally(tryNode);
@@ -231,20 +213,16 @@ class UnreachableCodeElimination implements CompilerPass {
         // which resulted in zero changes to the AST but triggered
         // reportCodeChange().
         // Instead, we should just ignore dead variable declarations.
-        return;
+        return null;
       }
-
-      removeNode(n);
-    }
-
-    private void removeNode(Node n) {
-      codeChanged = true;
-      NodeUtil.redeclareVarsInsideBranch(n);
-      compiler.reportCodeChange();
       if (logger.isLoggable(Level.FINE)) {
         logger.fine("Removing " + n.toString());
       }
+      codeChanged = true;
+      compiler.reportCodeChange();
+      NodeUtil.redeclareVarsInsideBranch(n);
       NodeUtil.removeChild(n.getParent(), n);
+      // We can try removing this node's parent.
+      return n.getParent();
     }
-  }
-}
+  }}
