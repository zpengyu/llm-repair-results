diff --git a/src/main/java/org/jsoup/safety/Cleaner.java b/src/main/java/org/jsoup/safety/Cleaner.java
index c6879b1..0173593 100644
--- a/src/main/java/org/jsoup/safety/Cleaner.java
+++ b/src/main/java/org/jsoup/safety/Cleaner.java
@@ -18,23 +18,23 @@ import java.util.List;
  <p/>
  Rather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.
  */
-public class Cleaner {
+class Cleaner {
     private Whitelist whitelist;
-
     /**
-     Create a new cleaner, that sanitizes documents using the supplied whitelist.
-     @param whitelist white-list to clean with
+     * Create a new cleaner, that sanitizes documents using the supplied whitelist.
+     *
+     * @param whitelist white-list to clean with
      */
     public Cleaner(Whitelist whitelist) {
         Validate.notNull(whitelist);
         this.whitelist = whitelist;
     }
-
     /**
-     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.
-     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.
-     @param dirtyDocument Untrusted base document to clean.
-     @return cleaned document.
+     * Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.
+     * The original document is not modified. Only elements from the dirt document's <code>body</code> are used.
+     *
+     * @param dirtyDocument Untrusted base document to clean.
+     * @return cleaned document.
      */
     public Document clean(Document dirtyDocument) {
         Validate.notNull(dirtyDocument);
@@ -42,19 +41,18 @@ public class Cleaner {
         Document clean = Document.createShell(dirtyDocument.baseUri());
         if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.
             copySafeNodes(dirtyDocument.body(), clean.body());
-
         return clean;
     }
-
     /**
-     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes
-     in the input HTML are allowed by the whitelist.
-     <p/>
-     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully
-     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document
-     to ensure enforced attributes are set correctly, and that the output is tidied.
-     @param dirtyDocument document to test
-     @return true if no tags or attributes need to be removed; false if they do
+     * Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes
+     * in the input HTML are allowed by the whitelist.
+     * <p/>
+     * This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully
+     * using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document
+     * to ensure enforced attributes are set correctly, and that the output is tidied.
+     *
+     * @param dirtyDocument document to test
+     * @return true if no tags or attributes need to be removed; false if they do
      */
     public boolean isValid(Document dirtyDocument) {
         Validate.notNull(dirtyDocument);
@@ -63,9 +60,8 @@ public class Cleaner {
         int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
         return numDiscarded == 0;
     }
-
     /**
-     Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.
+     * Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.
      */
     private int copySafeNodes(Element root, Element destination) {
         List<Node> sourceChildren = root.childNodes();
@@ -79,12 +73,12 @@ public class Cleaner {
                     ElementMeta meta = createSafeElement(sourceEl);
                     Element destChild = meta.el;
                     destination.appendChild(destChild);
-
                     numDiscarded += meta.numAttribsDiscarded;
                     numDiscarded += copySafeNodes(sourceEl, destChild);
-                } else {
-                    numDiscarded++;
-                    numDiscarded += copySafeNodes(sourceEl, destination);
+                } else if (source instanceof TextNode) {
+                    TextNode sourceText = (TextNode) source;
+                    TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());
+                    destination.appendChild(destText);
                 }
             } else if (source instanceof TextNode) {
                 TextNode sourceText = (TextNode) source;
