private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {
    // limit (no cache):
    if (count > maxStringCacheLen)
        return new String(charBuf, start, count);
    // calculate hash:
    int hash = 0;
    int offset = start;
    for (int i = 0; i < count; i++) {
        hash = 31 * hash + charBuf[offset++];
    }
    // get from cache
    final int index = hash & stringCache.length - 1;
    String cached = stringCache[index];
    if (cached == null) { // miss, add
        cached = new String(charBuf, start, count);
        stringCache[index] = cached;
    } else { // hashcode hit, check equality
        if (rangeEquals(charBuf, start, count, cached)) { // hit
            return cached;
        } else if (start == 0 && count == charBuf.length) { // if input is the full buffer, can't be a hashcode conflict (as full buffer hash is correct)
            cached = new String(charBuf, start, count); // so update cache
            stringCache[index] = cached;
        }
    }
    return cached;
}