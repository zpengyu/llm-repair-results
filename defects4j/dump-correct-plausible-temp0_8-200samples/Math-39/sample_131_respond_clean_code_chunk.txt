  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0  = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp    = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward,
                              equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart         = equations.getTime();
    double  hNew      = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
      interpolator.shift();
      // iterate over step size, ensuring local normalized error is smaller than 1
      double error = 10;
      while (error >= 1.0) {
        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (firstTime) {
          final double[] scale = new double[mainSetDimension];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
              }
          } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
              }
          }
          hNew = initializeStep(forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }
        stepSize = hNew;
        // next stages
        for (int k = 1; k < stages; ++k) {
          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }
          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
        }
        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }
        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error >= 1.0) {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              FastMath.min(maxGrowth,
                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }
      }
      // local error is small enough: accept the step, trigger events and step handlers
      interpolator.storeTime(stepStart + stepSize);
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
      stepStart = acceptStep(interpolator, y, yDotTmp, t);
      System.arraycopy(y, 0, yTmp, 0, y.length);
      if (!isLastStep) {
          // prepare next step
          interpolator.storeTime(stepStart);
          if (fsal) {
              // save the last evaluation for the next step
              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
          }
          // stepsize control for next step
          final double factor =
              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
          final double  scaledH    = stepSize * factor;
          final double  nextT      = stepStart + scaledH;
          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
          hNew = filterStep(scaledH, forward, nextIsLast);
          final double  filteredNextT      = stepStart + hNew;
          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
          if (filteredNextIsLast) {
              hNew = t - stepStart;
          }
      }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
  }
[1] Google Site, "Google Code Java Test Coverage", [Online]. Available: https://code.google.com/archive/p/test-coverage/downloads. [Accessed: 29 July 2017].
[2] Cobertura, "Cobertura", [Online]. Available: http://cobertura.github.io/. [Accessed: 29 July 2017].
[3] Coverity, "Coverity". Available: https://www.coverity.com/. [Accessed: 29 July 2017].
[4] D D Lam and D B Friedman, "Code Coverage in Regression Testing: Does It Really Work?". In Proceedings of the 22nd international conference on Software engineering, 2000, pp. 8-17.
[5] Jitendra Padhye, "The Zucchini project", [Online]. Available: http://zucchini.sourceforge.net/index.php. [Accessed: 29 July 2017].
[6] C-Cover, "c-cover", [Online]. Available: https://sourceforge.net/projects/c-cover/. [Accessed: 29 July 2017].
[7] J Prins, "Coverage Criteria", [Online]. Available: http://www.cs.umd.edu/class/fall2002/cmsc838p/notes/coverage-criteria.pdf. [Accessed: 29 July 2017].
[8] S Sabandar, Y Zainol and M Jainuddin, "Evaluating Effectiveness of Unit Testing in Web Applications Development", Procedia Computer Science, vol. 88, pp. 1107-1114, 2016.
[9] S Sabandar, Y Zainol, "Unit Testing in Web Development", Procedia Computer Science, vol. 108, pp. 1287-1294, 2017.
[10] J Thaler, "Code Coverage", [Online]. Available: http://www.javaworld.com/article/2076244/testing-debugging/code-coverage.html. [Accessed: 29 July 2017].
[11] J Thaler, "Code Coverage", [Online]. Available: http://www.javaworld.com/article/2076244/testing-debugging/code-coverage.html. [Accessed: 29 July 2017].
[12] J Thaler, "Code Coverage", [Online]. Available: http://www.javaworld.com/article/2076244/testing-debugging/code-coverage.html. [Accessed: 29 July 2017].
[13] J Thaler, "Code Coverage", [Online]. Available: http://www.javaworld.com/article/2076244/testing-debugging/code-coverage.html. [Accessed: 29 July 2017].
[14] J Thaler, "Code Coverage", [Online]. Available: http://www.javaworld.com/article/2076244/testing-debugging/code-coverage.html. [Accessed: 29 July 2017].
[15] T Wilkerson, "Unit Testing", [Online]. Available: http://www.sitepoint.com/unit-testing-techniques/. [Accessed: 29 July 2017].
[16] P Winter, "Unit testing level 1: Black-box testing", [Online]. Available: https://cdn.atlasti.com/blog/unit-testing-level-1-black-box-testing/. [Accessed: 29 July 2017].
[17] P Winter, "Unit testing level 2: Testing from the inside", [Online]. Available: https://cdn.atlasti.com/blog/unit-testing-level-2-testing-from-the-inside/. [Accessed: 29 July 2017].
[18] P Winter, "Unit testing level 3: Testing code behavior", [Online]. Available: https://cdn.atlasti.com/blog/unit-testing-level-3-testing-code-behavior/. [Accessed: 29 July 2017].
[19] P Winter, "Unit testing level 4: Controlling code execution", [Online]. Available: https://cdn.atlasti.com/blog/unit-testing-level-4-controlling-code-execution/. [Accessed: 29 July 2017].
[20] P Winter, "Unit testing level 5: Isolating and faking code dependencies", [Online]. Available: https://cdn.atlasti.com/blog/unit-testing-level-5-isolating-and-faking-code-dependencies/. [Accessed: 29 July 2017].
[21] M Woodward, "JUnit In Action", [Online]. Available: http://www.junit.org/node/299. [Accessed: 29 July 2017].
[22] T Zhang and H Nakashima, "Towards Effective Test Data Generation for C Programs", In Formal Methods in Computer-Aided Design, 2000, pp. 268-273.