diff --git a/src/org/mockito/internal/MockHandler.java b/src/org/mockito/internal/MockHandler.java
index 9452f1664..ba49edbc4 100644
--- a/src/org/mockito/internal/MockHandler.java
+++ b/src/org/mockito/internal/MockHandler.java
@@ -82,29 +79,27 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
-        
-        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
-        mockingProgress.reportOngoingStubbing(ongoingStubbing);
-
-        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
-
-        if (stubbedInvocation != null) {
-            stubbedInvocation.captureArgumentsFrom(invocation);
-            return stubbedInvocation.answer(invocation);
-        } else {
-            Object ret = mockSettings.getDefaultAnswer().answer(invocation);
-
-            // redo setting invocation for potential stubbing in case of partial
-            // mocks / spies.
-            // Without it, the real method inside 'when' might have delegated
-            // to other self method and overwrite the intended stubbed method
-            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
-            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
-            return ret;
+        if (mockSettings.isStubOnly()) {
+            invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
+            OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
+            mockingProgress.reportOngoingStubbing(ongoingStubbing);
+            StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);
+            if (stubbedInvocation != null) {
+                stubbedInvocation.captureArgumentsFrom(invocation);
+                return stubbedInvocation.answer(invocation);
+            } else {
+                Object ret = mockSettings.getDefaultAnswer().answer(invocation);
+                // redo setting invocation for potential stubbing in case of partial
+                // mocks / spies.
+                // Without it, the real method inside 'when' might have delegated
+                // to other self method and overwrite the intended stubbed method
+                // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
+                invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
+                return ret;
+            }
         }
+        return null;
     }
-
     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {
         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);
     }
