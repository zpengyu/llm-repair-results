diff --git a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java
index f516e584..dc668f9c 100644
--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java
+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java
@@ -152,19 +147,23 @@ public class ProcessCommonJSModules implements CompilerPass {
     private void visitRequireCall(NodeTraversal t, Node require, Node parent) {
       String moduleName = toModuleName(require.getChildAtIndex(1).getString(),
           normalizeSourceName(t.getSourceName()));
-      Node moduleRef = IR.name(moduleName).srcref(require);
-      parent.replaceChild(require, moduleRef);
-      Node script = getCurrentScriptNode(parent);
-      if (reportDependencies) {
-        t.getInput().addRequire(moduleName);
+      if (isInGoogModule()) {
+        moduleName = "module$exports$" + moduleName;
+        parent.replaceChild(require, IR.name(moduleName).srcref(require));
+      } else {
+        Node moduleRef = IR.name(moduleName).srcref(require);
+        parent.replaceChild(require, moduleRef);
+        Node script = getCurrentScriptNode(parent);
+        if (reportDependencies) {
+          t.getInput().addRequire(moduleName);
+        }
+        // Rewrite require("name").
+        script.addChildToFront(IR.exprResult(
+            IR.call(IR.getprop(IR.name("goog"), IR.string("require")),
+                IR.string(moduleName))).copyInformationFromForTree(require));
+        compiler.reportCodeChange();
       }
-      // Rewrite require("name").
-      script.addChildToFront(IR.exprResult(
-          IR.call(IR.getprop(IR.name("goog"), IR.string("require")),
-              IR.string(moduleName))).copyInformationFromForTree(require));
-      compiler.reportCodeChange();
     }
-
     /**
      * Emit goog.provide and add suffix to all global vars to avoid conflicts
      * with other modules.
@@ -173,30 +172,45 @@ public class ProcessCommonJSModules implements CompilerPass {
       Preconditions.checkArgument(scriptNodeCount == 1,
           "ProcessCommonJSModules supports only one invocation per " +
           "CompilerInput / script node");
+      if (isInGoogModule()) {
+        addExportInitializer(script);
+      } else {
+        String moduleName = guessCJSModuleName(normalizeSourceName(script
+            .getSourceFileName()));
+        script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
+            .copyInformationFromForTree(script));
+        if (reportDependencies) {
+          CompilerInput ci = t.getInput();
+          ci.addProvide(moduleName);
+          JSModule m = new JSModule(moduleName);
+          m.addAndOverrideModule(ci);
+          module = m;
+        }
+        script.addChildToFront(IR.exprResult(
+            IR.call(IR.getprop(IR.name("goog"), IR.string("provide")),
+                IR.string(moduleName))).copyInformationFromForTree(script));
+        emitOptionalModuleExportsOverride(script, moduleName);
+        // Rename vars to not conflict in global scope.
+        NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
+            moduleName));
+      }
+      compiler.reportCodeChange();
+    }
+    /**
+     * If the script represents a goog.module, add
+     * <code>module$exports$moduleName = moduleName || {}</code>
+     * before the first statement.
+     */
+    private void addExportInitializer(Node script) {
       String moduleName = guessCJSModuleName(normalizeSourceName(script
           .getSourceFileName()));
-      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
+      script.addChildToFront(IR.var(IR.name("module$exports$" + moduleName),
+          IR.or(IR.name(moduleName), IR.objectlit()))
+          .copyInformationFromForTree(script));
+      script.addChildToFront(IR.var(IR.name(moduleName),
+          IR.name("module$exports$" + moduleName))
           .copyInformationFromForTree(script));
-      if (reportDependencies) {
-        CompilerInput ci = t.getInput();
-        ci.addProvide(moduleName);
-        JSModule m = new JSModule(moduleName);
-        m.addAndOverrideModule(ci);
-        module = m;
-      }
-      script.addChildToFront(IR.exprResult(
-          IR.call(IR.getprop(IR.name("goog"), IR.string("provide")),
-              IR.string(moduleName))).copyInformationFromForTree(script));
-
-      emitOptionalModuleExportsOverride(script, moduleName);
-
-      // Rename vars to not conflict in global scope.
-      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
-          moduleName));
-
-      compiler.reportCodeChange();
     }
-
     /**
      * Emit <code>if (moduleName.module$exports) {
      *    moduleName = moduleName.module$export;
@@ -219,6 +231,9 @@ public class ProcessCommonJSModules implements CompilerPass {
      */
     private void visitModuleExports(Node prop) {
       String moduleName = guessCJSModuleName(prop.getSourceFileName());
+      if (isInGoogModule()) {
+        moduleName = "module$exports$" + moduleName;
+      }
       Node module = prop.getChildAtIndex(0);
       module.putProp(Node.ORIGINALNAME_PROP, "module");
       module.setString(moduleName);
@@ -238,8 +252,13 @@ public class ProcessCommonJSModules implements CompilerPass {
         n = n.getParent();
       }
     }
+    /**
+     * @return {@code true} iff the source name is a goog.module file name
+     */
+    private boolean isInGoogModule() {
+      return getCurrentScriptNode().getSourceFileName().endsWith(".js");
+    }
   }
-
   /**
    * Traverses a node tree and appends a suffix to all global variable names.
    */
