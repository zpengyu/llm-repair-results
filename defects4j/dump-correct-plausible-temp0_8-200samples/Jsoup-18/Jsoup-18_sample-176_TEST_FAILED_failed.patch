diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java
index 7f39fc5..1884413 100644
--- a/src/main/java/org/jsoup/parser/CharacterReader.java
+++ b/src/main/java/org/jsoup/parser/CharacterReader.java
@@ -7,19 +7,22 @@ import org.jsoup.helper.Validate;
  */
 class CharacterReader {
     static final char EOF = (char) -1;
-
+    static final int maxCacheLen = 12;
     private final String input;
     private final int length;
     private int pos = 0;
     private int mark = 0;
-
+    // used to cache the first characters of the input, up to the length of the longest input sequence.
+    private final char[] inputWindow;
     CharacterReader(String input) {
         Validate.notNull(input);
-
         this.input = input;
         this.length = input.length();
+        inputWindow = new char[maxCacheLen];
+        for (int i = 0; i < Math.min(input.length(), maxCacheLen); i++) {
+            inputWindow[i] = input.charAt(i);
+        }
     }
-
     int pos() {
         return pos;
     }
@@ -27,13 +29,11 @@ class CharacterReader {
     boolean isEmpty() {
         return pos >= length;
     }
-
     char current() {
-        return isEmpty() ? EOF : input.charAt(pos);
+        return isEmpty() ? EOF : inputWindow[pos];
     }
-
     char consume() {
-        char val = isEmpty() ? EOF : input.charAt(pos);
+        char val = isEmpty() ? EOF : inputWindow[pos];
         pos++;
         return val;
     }
@@ -53,109 +49,117 @@ class CharacterReader {
     void rewindToMark() {
         pos = mark;
     }
-
     String consumeAsString() {
-        return input.substring(pos, pos++);
+        return new String(inputWindow, pos, 1);
     }
-
     String consumeTo(char c) {
-        int offset = input.indexOf(c, pos);
-        if (offset != -1) {
-            String consumed = input.substring(pos, offset);
-            pos += consumed.length();
-            return consumed;
-        } else {
-            return consumeToEnd();
+        int offset = pos;
+        while (offset < length && inputWindow[offset] != c) {
+            offset++;
         }
+        String consumed;
+        if (offset < length)
+            consumed = new String(inputWindow, pos, offset - pos);
+        else
+            consumed = new String(inputWindow, pos, length - pos);
+        pos += consumed.length();
+        return consumed;
     }
-
     String consumeTo(String seq) {
-        int offset = input.indexOf(seq, pos);
-        if (offset != -1) {
-            String consumed = input.substring(pos, offset);
-            pos += consumed.length();
-            return consumed;
-        } else {
-            return consumeToEnd();
+        int offset = pos;
+        while (offset < length) {
+            int cmp = 0;
+            for (int i = 0; i < seq.length() && (offset + i < length); i++) {
+                cmp = Character.toLowerCase(inputWindow[offset + i]) - Character.toLowerCase(seq.charAt(i));
+                if (cmp != 0)
+                    break;
+            }
+            if (cmp == 0)
+                break;
+            offset++;
         }
+        String data;
+        if (offset < length)
+            data = new String(inputWindow, pos, offset - pos);
+        else
+            data = new String(inputWindow, pos, length - pos);
+        pos += data.length();
+        return data;
     }
-
     String consumeToAny(char... seq) {
-        int start = pos;
-
-        OUTER: while (!isEmpty()) {
-            char c = input.charAt(pos);
-            for (char seek : seq) {
-                if (seek == c)
-                    break OUTER;
+        int offset = pos;
+        while (offset < length) {
+            for (char c : seq) {
+                if (inputWindow[offset] == c)
+                    break;
             }
-            pos++;
+            offset++;
         }
-
-        return pos > start ? input.substring(start, pos) : "";
+        String data;
+        if (offset < length)
+            data = new String(inputWindow, pos, offset - pos);
+        else
+            data = new String(inputWindow, pos, length - pos);
+        pos += data.length();
+        return data;
     }
-
     String consumeToEnd() {
-        String data = input.substring(pos, input.length() - 1);
-        pos = input.length();
+        String data = new String(inputWindow, pos, length - pos);
+        pos = length;
         return data;
     }
-
     String consumeLetterSequence() {
         int start = pos;
-        while (!isEmpty()) {
-            char c = input.charAt(pos);
+        while (pos < length) {
+            char c = inputWindow[pos];
             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
                 pos++;
             else
                 break;
         }
-
-        return input.substring(start, pos);
+        return new String(inputWindow, start, pos - start);
     }
-
     String consumeHexSequence() {
         int start = pos;
-        while (!isEmpty()) {
-            char c = input.charAt(pos);
+        while (pos < length) {
+            char c = inputWindow[pos];
             if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
                 pos++;
             else
                 break;
         }
-        return input.substring(start, pos);
+        return new String(inputWindow, start, pos - start);
     }
-
     String consumeDigitSequence() {
         int start = pos;
-        while (!isEmpty()) {
-            char c = input.charAt(pos);
+        while (pos < length) {
+            char c = inputWindow[pos];
             if (c >= '0' && c <= '9')
                 pos++;
             else
                 break;
         }
-        return input.substring(start, pos);
+        return new String(inputWindow, start, pos - start);
     }
-
     boolean matches(char c) {
-        return !isEmpty() && input.charAt(pos) == c;
-
+        return !isEmpty() && inputWindow[pos] == c;
     }
-
     boolean matches(String seq) {
-        return input.startsWith(seq, pos);
+        int scanLength = seq.length();
+        if (scanLength > inputWindow.length - pos)
+            return false;
+        for (int offset = 0; offset < scanLength; offset++)
+            if (Character.toLowerCase(inputWindow[pos + offset]) != Character.toLowerCase(seq.charAt(offset)))
+                return false;
+        return true;
     }
-
     boolean matchesIgnoreCase(String seq) {
-        return input.regionMatches(true, pos, seq, 0, seq.length());
+        return matches(seq);
     }
-
     boolean matchesAny(char... seq) {
         if (isEmpty())
             return false;
-
-        char c = input.charAt(pos);
+        char c = inputWindow[pos];
         for (char seek : seq) {
             if (seek == c)
                 return true;
@@ -166,17 +169,15 @@ class CharacterReader {
     boolean matchesLetter() {
         if (isEmpty())
             return false;
-        char c = input.charAt(pos);
+        char c = inputWindow[pos];
         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
     }
-
     boolean matchesDigit() {
         if (isEmpty())
             return false;
-        char c = input.charAt(pos);
+        char c = inputWindow[pos];
         return (c >= '0' && c <= '9');
     }
-
     boolean matchConsume(String seq) {
         if (matches(seq)) {
             pos += seq.length();
@@ -185,25 +186,18 @@ class CharacterReader {
             return false;
         }
     }
-
     boolean matchConsumeIgnoreCase(String seq) {
-        if (matchesIgnoreCase(seq)) {
-            pos += seq.length();
-            return true;
-        } else {
-            return false;
-        }
+        return matchConsume(seq);
     }
-
     boolean containsIgnoreCase(String seq) {
         // used to check presence of </title>, </style>. only finds consistent case.
         String loScan = seq.toLowerCase();
         String hiScan = seq.toUpperCase();
-        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);
+        String target = new String(inputWindow, pos, length - pos);
+        return (target.indexOf(loScan) > -1) || (target.indexOf(hiScan) > -1);
     }
-
     @Override
     public String toString() {
-        return input.substring(pos);
+        return new String(inputWindow, pos, length - pos);
     }
 }
\ No newline at end of file
