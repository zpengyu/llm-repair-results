###Provide a fix for the buggy function
###Buggy Function
class FibonacciExample {
    public static void main(String args[]) {
        int n1 = 0, n2 = 1, n3, i, count = 10;

        System.out.print(n1 + " " + n2);

        for (i = 2; i < count; ++i) {
            n3 = n1 - n2;
            System.out.print(" " + n3);
            n1 = n2;
            n2 = n3;
        }
    }
}

###Fixed Function
class FibonacciExample {
    public static void main(String args[]) {
        int n1 = 0, n2 = 1, n3, i, count = 10;

        System.out.print(n1 + " " + n2);

        for (i = 2; i < count; ++i) {
            n3 = n1 + n2;
            System.out.print(" " + n3);
            n1 = n2;
            n2 = n3;
        }
    }
}

###Provide a fix for the buggy function
###Buggy Function
protected void setName(String name) {
    this.name = name;
}
###Fixed Function
protected void setName(String name) {
   if (name != null && getPlatform() == PLATFORM_FAT
       && name.indexOf("/") == -1) {
       name = name.replace('\\', '/');
   }
}
###Provide a fix for the buggy function
###Buggy Function
    Map<String, String> parsePaxHeaders(final InputStream i)
        throws IOException {
        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
        // Format is "length keyword=value\n";
        while(true){ // get length
            int ch;
            int len = 0;
            int read = 0;
            while((ch = i.read()) != -1) {
                read++;
                if (ch == ' '){
                    // Get keyword
                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();
                    while((ch = i.read()) != -1) {
                        read++;
                        if (ch == '='){ // end of keyword
                            final String keyword = coll.toString(CharsetNames.UTF_8);
                            // Get rest of entry
                            final int restLen = len - read;
                            if (restLen == 1) { // only NL
                                headers.remove(keyword);
                            } else {
                                final byte[] rest = new byte[restLen];
                                final int got = IOUtils.readFully(i, rest);
                                if (got != restLen) {
                                    throw new IOException("Failed to read "
                                                          + "Paxheader. Expected "
                                                          + restLen
                                                          + " bytes, read "
                                                          + got);
                                }
                                // Drop trailing NL
                                final String value = new String(rest, 0,
                                                          restLen - 1, CharsetNames.UTF_8);
                                headers.put(keyword, value);
                            }
                            break;
                        }
                        coll.write((byte) ch);
                    }
                    break; // Processed single header
                }
                len *= 10;
                len += ch - '0';
            }
            if (ch == -1){ // EOF
                break;
            }
        }
        return headers;
    }

###Fixed Function
