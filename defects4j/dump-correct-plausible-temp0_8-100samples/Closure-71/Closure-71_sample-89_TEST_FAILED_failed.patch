diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java
index c4ecc477..8f0aeb8d 100644
--- a/src/com/google/javascript/jscomp/CheckAccessControls.java
+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java
@@ -413,15 +412,11 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {
     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
-      boolean isOverride = t.inGlobalScope() &&
+      boolean isOverride =
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
-
       // Find the lowest property defined on a class with visibility
       // information.
-      if (isOverride) {
-        objectType = objectType.getImplicitPrototype();
-      }
       JSDocInfo docInfo = null;
       for (; objectType != null;
            objectType = objectType.getImplicitPrototype()) {
@@ -436,11 +430,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {
         // We couldn't find a visibility modifier; assume it's public.
         return;
       }
-
-      boolean sameInput =
-          t.getInput().getName().equals(docInfo.getSourceName());
       Visibility visibility = docInfo.getVisibility();
-      JSType ownerType = normalizeClassType(objectType);
       if (isOverride) {
         // Check an ASSIGN statement that's trying to override a property
         // on a superclass.
@@ -451,7 +440,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {
         // Check that (a) the property *can* be overridden, and
         // (b) that the visibility of the override is the same as the
         // visibility of the original property.
-        if (visibility == Visibility.PRIVATE && !sameInput) {
+        if (visibility == Visibility.PRIVATE) {
           compiler.report(
               t.makeError(getprop, PRIVATE_OVERRIDE,
                   objectType.toString()));
@@ -463,16 +452,10 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {
                   overridingVisibility.name()));
         }
       } else {
-        if (sameInput) {
-          // private access is always allowed in the same file.
+        if (t.inGlobalScope() && visibility == Visibility.PRIVATE) {
+          // private access is allowed in the same file.
           return;
-        } else if (visibility == Visibility.PRIVATE &&
-            (currentClass == null || ownerType.differsFrom(currentClass))) {
-          if (docInfo.isConstructor() &&
-              isValidPrivateConstructorAccess(parent)) {
-            return;
-          }
-
+        } else if (visibility == Visibility.PRIVATE) {
           // private access is not allowed outside the file from a different
           // enclosing class.
           compiler.report(
@@ -487,7 +470,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {
           // 2) Overriding the property in a subclass
           // 3) Accessing the property from inside a subclass
           // The first two have already been checked for.
-          if (currentClass == null || !currentClass.isSubtype(ownerType)) {
+          if (currentClass == null || !currentClass.isSubtype(objectType)) {
             compiler.report(
                 t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
                     propertyName,
