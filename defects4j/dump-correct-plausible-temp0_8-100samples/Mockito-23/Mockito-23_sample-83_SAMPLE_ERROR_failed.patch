diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
index c4384f7fc..f3c94b5f5 100644
--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
@@ -37,94 +37,140 @@ import org.mockito.stubbing.Answer;
  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS
  * @see org.mockito.Answers#RETURNS_DEEP_STUBS
  */
-public class ReturnsDeepStubs implements Answer<Object>, Serializable {
-    
-    private static final long serialVersionUID = -7105341425736035847L;
-
-    private MockitoCore mockitoCore = new MockitoCore();
-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
-
-    public Object answer(InvocationOnMock invocation) throws Throwable {
-        GenericMetadataSupport returnTypeGenericMetadata =
-                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
-
-        Class<?> rawType = returnTypeGenericMetadata.rawType();
-        if (!mockitoCore.isTypeMockable(rawType)) {
-            return delegate.returnValueFor(rawType);
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.implementation.MethodCall;
+import net.bytebuddy.matcher.ElementMatchers;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import java.io.Serializable;
+import java.lang.reflect.Modifier;
+import java.util.HashSet;
+import java.util.Set;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+public class ObjenesisTestClass {
+    static interface TestInterface {
+        String getString();
+    }
+    static class TestClass implements TestInterface {
+        private String s = "";
+        public void setString(String s) {
+            this.s = s;
+        }
+        @Override
+        public String getString() {
+            return s;
         }
-
-        return getMock(invocation, returnTypeGenericMetadata);
     }
-
-
-
-    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
-    	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
-    	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
-
-        // matches invocation for verification
-        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
-    		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
-    			return stubbedInvocationMatcher.answer(invocation);
-    		}
-		}
-
-        // deep stub
-        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
+    TestInterface testInterface;
+    TestClass testClass;
+    @Before
+    public void setup() {
+        testInterface = mock(TestInterface.class);
+        testClass = mock(TestClass.class);
     }
-
-    /**
-     * Creates a mock using the Generics Metadata.
-     *
-     * <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data
-     * that was resolved for the current return type, for this to happen we associate to the mock an new instance of
-     * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.
-     *
-     * @param returnTypeGenericMetadata The metadata to use to create the new mock.
-     * @return The mock
-     */
-    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
-        return mockitoCore.mock(
-                returnTypeGenericMetadata.rawType(),
-                withSettingsUsing(returnTypeGenericMetadata)
-        );
+    @Test
+    public void mockTestInterface() {
+        when(testInterface.getString()).thenReturn("test");
+        assertThat(testInterface.getString(), is("test"));
     }
-
-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
-        MockSettings mockSettings =
-                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
-                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
-                : withSettings();
-
-        return mockSettings
-                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
+    @Test
+    public void mockTestClass() {
+        when(testClass.getString()).thenReturn("test");
+        assertThat(testClass.getString(), is("test"));
     }
-
-    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
-        return new ReturnsDeepStubs() {
-            @Override
-            protected GenericMetadataSupport actualParameterizedType(Object mock) {
-                return returnTypeGenericMetadata;
-            }
-        };
+    @Test
+    public void mockTestClass_useCallRealMethod() {
+        when(testClass.getString()).thenCallRealMethod();
+        testClass.setString("test");
+        assertThat(testClass.getString(), is("test"));
     }
-
-    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
-
-        container.addAnswer(new Answer<Object>() {
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                return mock;
-            }
-        }, false);
-
-        return mock;
+    @Test
+    public void newInstanceTest() {
+        try {
+            new ByteBuddy().subclass(TestInterface.class).method(ElementMatchers.named("getString"))
+                    .intercept(MethodCall.invoke(String.class.getDeclaredMethod("valueOf", boolean.class)))
+                    .make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                    .getLoaded().newInstance();
+            assertEquals(true, false);
+        } catch (InstantiationException e) {
+            assertEquals(true, false);
+        } catch (Exception e) {
+            assertEquals(true, true);
+        }
     }
-	
-		
-	
-
-    protected GenericMetadataSupport actualParameterizedType(Object mock) {
-        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();
-        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());
+    @Test
+    public void newInterfaceInstance() {
+        try {
+            TestInterface test = new ByteBuddy().subclass(TestInterface.class).method(ElementMatchers.named("getString"))
+                    .intercept(MethodCall.invoke(String.class.getDeclaredMethod("valueOf", boolean.class)))
+                    .make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                    .getLoaded().newInstance();
+            assertEquals(true, true);
+            assertEquals(test.getString(), "false");
+        } catch (Exception e) {
+            assertEquals(true, false);
+        }
+    }
+    @Test
+    public void newClassInstance() {
+        try {
+            TestClass test = new ByteBuddy().subclass(TestClass.class).method(ElementMatchers.named("getString"))
+                    .intercept(MethodCall.invoke(String.class.getDeclaredMethod("valueOf", boolean.class)))
+                    .make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                    .getLoaded().newInstance();
+            assertEquals(true, true);
+            assertEquals(test.getString(), "false");
+        } catch (Exception e) {
+            assertEquals(true, false);
+        }
+    }
+    @Test
+    public void mockNewInterfaceInstance() {
+        try {
+            TestInterface test = new ByteBuddy().subclass(TestInterface.class).method(ElementMatchers.named("getString"))
+                    .intercept(MethodCall.invoke(String.class.getDeclaredMethod("valueOf", boolean.class)))
+                    .make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                    .getLoaded().newInstance();
+            when(test.getString()).thenReturn("test");
+            assertEquals(test.getString(), "test");
+        } catch (Exception e) {
+            assertEquals(true, false);
+        }
+    }
+    @Test
+    public void mockNewClassInstance() {
+        try {
+            TestClass test = new ByteBuddy().subclass(TestClass.class).method(ElementMatchers.named("getString"))
+                    .intercept(MethodCall.invoke(String.class.getDeclaredMethod("valueOf", boolean.class)))
+                    .make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                    .getLoaded().newInstance();
+            when(test.getString()).thenReturn("test");
+            assertEquals(test.getString(), "test");
+        } catch (Exception e) {
+            assertEquals(true, false);
+        }
+    }
+    @Test
+    public void mockNewClassInstance_useCallRealMethod() {
+        try {
+            TestClass test = new ByteBuddy().subclass(TestClass.class).method(ElementMatchers.named("getString"))
+                    .intercept(MethodCall.invoke(String.class.getDeclaredMethod("valueOf", boolean.class)))
+                    .make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                    .getLoaded().newInstance();
+            when(test.getString()).thenCallRealMethod();
+            test.setString("test");
+            assertEquals(test.getString(), "test");
+        } catch (Exception e) {
+            assertEquals(true, false);
+        }
     }
 }
\ No newline at end of file
