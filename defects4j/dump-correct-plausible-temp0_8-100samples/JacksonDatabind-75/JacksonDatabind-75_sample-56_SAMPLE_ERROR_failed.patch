diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
index d72ea4ad1..c95c6d3cc 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
@@ -25,91 +25,80 @@ import com.fasterxml.jackson.databind.util.EnumValues;
  * scalar (String).
  */
 @JacksonStdImpl
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.annotation.JsonFormat.Shape;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.SerializableString;
+import com.fasterxml.jackson.core.io.SerializedString;
+import com.fasterxml.jackson.core.json.JsonWriteContext;
+import com.fasterxml.jackson.core.util.JsonGeneratorDelegate;
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;
+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;
+import com.fasterxml.jackson.databind.type.TypeFactory;
+import com.fasterxml.jackson.databind.util.EnumValues;
+import com.fasterxml.jackson.databind.util.NameTransformer;
+/**
+ * Base class used by standard serializers for serializing
+ * Java Enums according to standard convention: using
+ * String name or ordinal index.
+ * Uses {@link com.fasterxml.jackson.databind.annotation.JsonFormat}
+ * for configuration
+ *
+ * @since 2.3
+ */
+@SuppressWarnings("serial")
 public class EnumSerializer
     extends StdScalarSerializer<Enum<?>>
     implements ContextualSerializer
 {
-    private static final long serialVersionUID = 1L;
-
     /**
      * This map contains pre-resolved values (since there are ways
      * to customize actual String constants to use) to use as
      * serializations.
      */
     protected final EnumValues _values;
-
-    /**
-     * Flag that is set if we statically know serialization choice
-     * between index and textual format (null if it needs to be dynamically
-     * checked).
-     * 
-     * @since 2.1
-     */
-    protected final Boolean _serializeAsIndex;
-
     /*
     /**********************************************************
     /* Construction, initialization
     /**********************************************************
      */
-    
-    /**
-     * @deprecated Since 2.1
-     */
-    @Deprecated
-    public EnumSerializer(EnumValues v) {
-        this(v, null);
-    }
-
-    public EnumSerializer(EnumValues v, Boolean serializeAsIndex)
-    {
-        super(v.getEnumClass(), false);
+    protected EnumSerializer(EnumValues v) {
+        super(Enum.class, false);
         _values = v;
-        _serializeAsIndex = serializeAsIndex;
     }
-
-    /**
-     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}
-     * for constructing serializer instance of Enum types.
-     * 
-     * @since 2.1
-     */
     @SuppressWarnings("unchecked")
     public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,
             BeanDescription beanDesc, JsonFormat.Value format)
     {
-        /* 08-Apr-2015, tatu: As per [databind#749], we can not statically determine
-         *   between name() and toString(), need to construct `EnumValues` with names,
-         *   handle toString() case dynamically (for example)
-         */
+        // 08-Apr-2015, tatu: As per [databind#749], we can not statically determine
+        //   between name() and toString(), need to construct `EnumValues` with names,
+        //   handle toString() case dynamically (for example)
         EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass);
-        Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);
-        return new EnumSerializer(v, serializeAsIndex);
+        return new EnumSerializer(v);
     }
-
     /**
-     * To support some level of per-property configuration, we will need
-     * to make things contextual. We are limited to "textual vs index"
-     * choice here, however.
+     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}
+     * for constructing serializer instance of Enum types.
+     *
+     * @since 2.1
+     * @deprecated Since 2.8
      */
-    @Override
-    public JsonSerializer<?> createContextual(SerializerProvider serializers,
-            BeanProperty property) throws JsonMappingException
+    @Deprecated // since 2.8
+    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,
+            BeanDescription beanDesc)
     {
-        if (property != null) {
-            JsonFormat.Value format = findFormatOverrides(serializers,
-                    property, handledType());
-            if (format != null) {
-                Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(),
-                        format, false);
-                if (serializeAsIndex != _serializeAsIndex) {
-                    return new EnumSerializer(_values, serializeAsIndex);
-                }
-            }
-        }
-        return this;
+        return construct(enumClass, config, beanDesc, null);
     }
-
     /*
     /**********************************************************
     /* Extended API for Jackson databind core
@@ -123,24 +110,12 @@ public class EnumSerializer
     /* Actual serialization
     /**********************************************************
      */
-    
     @Override
-    public final void serialize(Enum<?> en, JsonGenerator gen, SerializerProvider serializers)
+    public void serialize(Enum<?> en, JsonGenerator g, SerializerProvider provider)
         throws IOException
     {
-        // [JACKSON-684]: serialize as index?
-        if (_serializeAsIndex(serializers)) {
-            gen.writeNumber(en.ordinal());
-            return;
-        }
-        // [databind#749]: or via toString()?
-        if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
-            gen.writeString(en.toString());
-            return;
-        }
-        gen.writeString(_values.serializedValueFor(en));
+        g.writeString(_values.serializedValueFor(en));
     }
-
     /*
     /**********************************************************
     /* Schema support
@@ -150,9 +124,6 @@ public class EnumSerializer
     @Override
     public JsonNode getSchema(SerializerProvider provider, Type typeHint)
     {
-        if (_serializeAsIndex(provider)) {
-            return createSchemaNode("integer", true);
-        }
         ObjectNode objectNode = createSchemaNode("string", true);
         if (typeHint != null) {
             JavaType type = provider.constructType(typeHint);
@@ -170,18 +140,12 @@ public class EnumSerializer
     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
         throws JsonMappingException
     {
-        SerializerProvider serializers = visitor.getProvider();
-        if (_serializeAsIndex(serializers)) {
-            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);
-            return;
-        }
         JsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);
         if (stringVisitor != null) {
             Set<String> enums = new LinkedHashSet<String>();
-            
             // Use toString()?
-            if ((serializers != null) && 
-                    serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
+            if ((visitor.getProvider() != null) &&
+                    visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
                 for (Enum<?> e : _values.enums()) {
                     enums.add(e.toString());
                 }
@@ -194,47 +158,31 @@ public class EnumSerializer
             stringVisitor.enumTypes(enums);
         }
     }
-
     /*
     /**********************************************************
-    /* Helper methods
+    /* Contextualization
     /**********************************************************
      */
-    
-    protected final boolean _serializeAsIndex(SerializerProvider serializers)
-    {
-        if (_serializeAsIndex != null) {
-            return _serializeAsIndex.booleanValue();
-        }
-        return serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX);
-    }
-
-    /**
-     * Helper method called to check whether serialization should be done using
-     * index (number) or not.
-     */
-    protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass,
-            JsonFormat.Value format, boolean fromClass)
+    @Override
+    public JsonSerializer<?> createContextual(SerializerProvider provider,
+            BeanProperty property) throws JsonMappingException
     {
-        JsonFormat.Shape shape = (format == null) ? null : format.getShape();
-        if (shape == null) {
-            return null;
-        }
-        // i.e. "default", check dynamically
-        if (shape == Shape.ANY || shape == Shape.SCALAR) {
-            return null;
-        }
-        // 19-May-2016, tatu: also consider "natural" shape
-        if (shape == Shape.STRING || shape == Shape.NATURAL) {
-            return Boolean.FALSE;
-        }
-        // 01-Oct-2014, tatu: For convenience, consider "as-array" to also mean 'yes, use index')
-        if (shape.isNumeric() || (shape == Shape.ARRAY)) {
-            return Boolean.TRUE;
+        JsonFormat.Value format = findFormatOverrides(provider, property, handledType());
+        if (format != null) {
+            if (format.hasShape()) {
+                Shape shape = format.getShape();
+                // 01-Oct-2014, tatu: For convenience, consider "as-array" to also mean 'yes, use index')
+                if (shape.isNumeric() || (shape == Shape.ARRAY)) {
+                    return this;
+                }
+                if ((shape == Shape.OBJECT) || (shape == Shape.STRING) || shape == Shape.NATURAL) {
+                    return this;
+                }
+                throw new IllegalArgumentException(String.format(
+                        "Unsupported serialization shape (%s) for Enum %s, not supported as %s annotation",
+                        shape, handledType().getName(), "property"));
+            }
         }
-        // 07-Mar-2017, tatu: Also means `OBJECT` not available as property annotation...
-        throw new IllegalArgumentException(String.format(
-                "Unsupported serialization shape (%s) for Enum %s, not supported as %s annotation",
-                    shape, enumClass.getName(), (fromClass? "class" : "property")));
+        return this;
     }
 }
\ No newline at end of file
